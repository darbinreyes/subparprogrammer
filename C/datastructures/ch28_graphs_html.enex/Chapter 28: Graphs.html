<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.14 (458244)"/><meta name="keywords" content="cornellcoursetextbook, datastructures, graphs, textbooknotes"/><meta name="altitude" content="39.09812927246094"/><meta name="author" content="Darbin E Reyes"/><meta name="created" content="2014-06-02 17:56:07 +0000"/><meta name="latitude" content="29.98885769279089"/><meta name="longitude" content="-95.58653477944515"/><meta name="updated" content="2016-05-04 17:21:11 +0000"/><title>Chapter 28: Graphs</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<div>Graph Vocab:</div>
<div>graph</div>
<div>vertices/nodes</div>
<div>edges</div>
<div>subgraph</div>
<div>undirected edges</div>
<div>directed edges</div>
<div>directed graph/digraph</div>
<div>path</div>
<div>simple path</div>
<div>length of a path</div>
<div>cycle</div>
<div>simple cycle</div>
<div>acyclic</div>
<div>weights/costs</div>
<div>weighted graph</div>
<div>connected graph</div>
<div>complete graph</div>
<div>disconnected</div>
<div>max number of edges</div>
<div>sparse graph ( O(n) edges ) vs dense graph ( O(n<sup>2</sup>) edges )</div>
<div><br/></div>
<div><br/></div>
<div>// trying new note sushi </div>
<div>1. double horizontal header for main sections </div>
<div>2. single  for sub sections starting with -bold title.</div>
<div>3. read and highlight first - then copy highlighted text into this note. - do this before starting the next section.</div>
<div>4. stop summarize 3-5 words.</div>
<div>5. Write keyword=, fill in with own words later.</div>
<div>6. prepare 3 titled sections at time (#1/2).</div>
<div><br/></div>
<div>
<hr/></div>
<div>-Introduction</div>
<div>
<hr/></div>
<div><br/></div>
<div>"<span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">graphs represent the relationships among data elements."</span></div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div>-Some Examples and Terminology</div>
<div>
<hr/></div>
<div><br/></div>
<div>// Recall meaning of "vertices" of a triangle.</div>
<div><br/></div>
<div>We encounter graphs everyday, we just don’t call them graphs.</div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Road Maps</b></div>
<div><br/></div>
<div>A road map is a graph.</div>
<div><br/></div>
<div><b>-Section 28.1-Intro. to basic Graph Vocabulary</b></div>
<div><br/></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"In a graph, the circles are called</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">vertices</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">, or</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">nodes</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">, and the lines are called</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">edges</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">. A</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">graph</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">, then, is a collection of distinct vertices and distinct edges."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">"A subgraph is a portion of a graph that is itself a graph, just as the road map in Figure 28-1 actually is a part of a larger map."</span></span></div>
<div><br/></div>
<div>"Since you can travel in both directions along the roads in Figure 28-1, the corresponding graph and its edges are said to be undirected."</div>
<div><br/></div>
<div>"The edges each have a direction and are called directed edges. A graph with directed edges is called a directed graph, or digraph."</div>
<div><br/></div>
<div>"You can transform an undirected graph into a directed graph by replacing each undirected edge with two directed edges that have opposite directions. "</div>
<div><br/></div>
<div>graph=</div>
<div>nodes/vertices/node/vertex=</div>
<div>edges=</div>
<div>subgraph=</div>
<div>undirected edge=</div>
<div>directed edge=</div>
<div>directed graph/digraph=</div>
<div><br/></div>
<div>
<hr/></div>
<div><br/></div>
<div><b>-Section 28.2-What is a “path” is a graph?</b></div>
<div><br/></div>
<div>"A path between two vertices in a graph is a sequence of edges. A path in a directed graph must consider the direction of the edges, and is called a directed path. The length of a path is the number of edges that it comprises. If the path does not pass through any vertex more than once, it is a simple path."</div>
<div><br/></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"A</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">cycle</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">is a path that begins and ends at the same vertex. A</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">simple cycle</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">passes through other vertices only once each."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 13px;"><span style="font-family: TimesNewRoman;">A simple cycle only visits the start/end vertex twice and all other vertices only once.</span></span></div>
<div><span style="font-size: 13px;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"A graph that has no cycles is</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">acyclic</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">path=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">directed path=</span></span></div>
<div><font face="TimesNewRoman"><span style="font-size: 10pt;">length of path= //note diff. btw meaning of a path</span><span style="font-size: 13px;">’s </span><span style="font-size: 10pt;">length and cost/weight</span></font></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">simple path=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">cycle=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">simply cycle=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">acyclic graph=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div>
<hr/></div>
<div><b>-Section 28.3-What is a weighted graph? What is an edge“weight/cost” is a</b> <b>weighted </b><b>graph?</b></div>
<div><br/></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">"Weights. You might be happy just to get from one place to another, but you often have a choice of several paths. You could choose the shortest, the fastest, or the cheapest path, for example. To do so, you use a weighted graph, which has values on its edges. These values are called either weights or costs. "</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"A path in a weighted graph also has a weight, or cost, that is the sum of its edge weights."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">-!! Path length !=Path weight/cost</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">weighted graph=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">edge weight/cost=</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">path weight/cost=</span></span></div>
<div>
<div>
<hr/></div>
</div>
<div><b>-Section 28.4-Names for graphs with a special property in their shape.</b></div>
<div><b><br/></b></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"A graph that has a path between every pair of distinct vertices is</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">connected</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">. A</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">complete graph</span> <font face="TimesNewRoman"><span style="font-size: 10pt;">goes even further; it has an edge between every pair of distinct vertices.</span><span style="font-size: 13px;">”</span><span style="font-size: 10pt;"> </span><span style="font-size: 13px;">“</span><span style="font-size: 10pt;">...disconnected—that is, not connected. "</span></font></div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/E2711B1E-49E4-4F44-A80E-92C28EBD904A.png" height="379" width="1069"/></div>
<div><br/></div>
<div>connected graph= //"you can get from here to there."</div>
<div>disconnected graph=</div>
<div>complete graph=</div>
<div><br/></div>
<div>
<div>
<div>
<hr/></div>
</div>
</div>
<div><b>-Section 28.5-What are adjacent vertices?</b></div>
<div><b><br/></b></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"Adjacent vertices are called</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">neighbors</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">."</span></div>
<div><br/></div>
<div>but what does it mean for two vertices to be “Adjacent”? The answer depends on if we are dealing with an undirected vs. directed graph.</div>
<div><br/></div>
<div>"Two vertices are adjacent in an undirected graph if they are joined by an edge.” // if I am a vertex in an undirected graph, the any edge connected to me is attached to an adjacent vertex.</div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">reiterating: "Adjacent vertices are called</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Bold'">neighbors</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">."</span></div>
<div><br/></div>
<div>"In a directed graph, vertex i is adjacent to vertex j if a directed edge</div>
<div>begins at j and ends at i.” // if I am a vertex in a directed graph, then any directed edge pointing to me is attached to an adjacent vertex.Hence those vertices are also my neighbors. Thus in a directed graph the neighbors relationship is not always bi-directional. "That is, vertex A is vertex B’s neighbor, but the converse is not true."</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/AC702F11-8E26-41A3-A6DD-55A92EC72A7B.png" height="326" width="995"/></div>
<div><br/></div>
<div>// !!!!! Clarification on definition of neighbor see fig. 28-10. In a directed graph you point to your neighbors.</div>
<div><br/></div>
<div>(undirected graph)adjacent vertices=</div>
<div>(directed graph)adjacent vertices=</div>
<div>neighbor vertices=adjacent vertices.</div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.6-Things to note about the number of edges in a graph. +Counting the number of edges in a complete graph.</b></div>
<div><br/></div>
<div><br/></div>
<div>"The number of edges. If a directed graph has n vertices, how many edges can it have? If the graph is complete, each vertex is a neighbor of all the other vertices. Thus, each vertex ends n - 1 directed edges. Consequently, the graph has n (n - 1) edges. A complete undirected graph has half that num- ber of edges."</div>
<div><br/></div>
<div>"A graph is sparse if it has relatively few edges. It is dense if it has many edges. While these terms have <span style="color: rgb(255, 38, 0);">no precise definition,</span> <span style="color: rgb(255, 38, 0);">we will say</span> that a sparse graph has O(n) edges, and a dense graph has O(n2) edges."</div>
<div><br/></div>
<div>"Typical graphs are sparse."</div>
<div><br/></div>
<div>sparse graph=</div>
<div>dense graph=</div>
<div><br/></div>
<div>
<div>
<hr/></div>
</div>
<div><b>-Airline Routes</b></div>
<div><b>-Section 28.7-Another everyday example of a graph</b></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"Algorithms exist that see whether a flight between given cities is possible."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">"Figure 28-6 contains one graph that consists of two distinct subgraphs. Although each subgraph is connected, the entire graph is disconnected."</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/C001E138-89DC-42DF-86AD-D90A9B8D87C2.png" height="452" width="1081"/></div>
<div>Note that in pictures we can tell whether the graph is directed by looking at the edges to see if they have arrows indicating direction. Otherwise if the edge is drawn as a simple line we know its an undirected graph.</div>
<div><br/></div>
<div>//no new keywords</div>
<div><br/></div>
<div>
<div>
<div>
<hr/></div>
</div>
</div>
<div><b>-Mazes</b></div>
<div><b>-Section 28.8-Another everyday example of a graph</b></div>
<div><br/></div>
<div>
<div>"We can represent this maze as a graph by placing a vertex at the entrance and exit, at each turn in the path, and at each dead end, as Figure 28-7b shows. This graph, like the road map in Figure 28-1, is connected. For such graphs, we can find a path between any two vertices, as you will see later in this chapter."</div>
<div><br/></div>
</div>
<div>This is a hint that we will learn the also for finding a path between two vertices in a connected graph.</div>
<div>
<div>//no new keywords</div>
</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/C7615FC6-0C28-4C20-98EF-555D4E35D801.png" height="516" width="1084"/></div>
<div>
<div>
<div>
<hr/></div>
</div>
</div>
<div><b>-Course Prerequisites</b></div>
<div><b>-Section 28.9-Another everyday example of a graph</b></div>
<div><br/></div>
<div>"This graph has no cycles. In a directed graph without cycles, we can arrange the vertices so that vertex a precedes vertex b whenever a directed edge exists from a to b. The order of the vertices in this arrangement is called a topological order."</div>
<div><br/></div>
<div>Later we will learn the algorithm for determining the topological order of the vertices in a directed graph that has no cycles (acyclic digraph).</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/168A5879-409D-401D-9847-30CE695B38E9.png" height="418" width="1088"/></div>
<div>(acyclic digraph) topological order=</div>
<div><br/></div>
<div>
<div>
<div>
<hr/></div>
</div>
</div>
<div><b>-Trees</b></div>
<div><b>-Section 28.10-Another everyday example of a graph. A tree IS A special case graph.</b></div>
<div><br/></div>
<div>"The ADT tree is a kind of graph that uses parent-child relationships to organize its nodes in a hier- archical fashion. One particular node, the root, is the ancestor of all other nodes in the tree."</div>
<div><br/></div>
<div>A tree is hierachical , just like a topologically sorted acyclic digraph. The root of the tree is similar to the first vertex in the topological order of an acyclic digraph.</div>
<div><br/></div>
<div>"A tree is a connected graph without cycles."</div>
<div>Obviously,  not all graphs can be called trees, only some graphs can be called trees.</div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div>Traversals</div>
<div>
<hr/></div>
<div><b>-Section 28.11</b></div>
<div><b><br/></b></div>
<div>"As you learned in earlier chapters, you usually search a tree for a node that contains a particular value. In graph applications, however, we focus on the connections between vertices, rather than the contents of vertices."</div>
<div><br/></div>
<div>Trees vs. Graphs Traversals</div>
<div><br/></div>
<div>With a graph we are interested in the connections between nodes instead of the nodes themselves (nodes=vertices) . However,  Graph applications still are usually based on traversals of the nodes (vertices) just like trees applications often are.</div>
<div><br/></div>
<div>Graph Depth First Traversal= "After visiting a vertex, this traversal visits the vertex’s neighbor, the neighbor’s neighbor, and so on."</div>
<div>Graph Breadth First Traversal = "In a graph, a breadth-first traversal visits all neighbors of a node before visiting the neighbors’ neighbors."</div>
<div><br/></div>
<div>Visit a node= "is an action that we perform during a tra- versal.” <span style="font-size: 13px;"><span style="font-family: TimesNewRoman;">"</span></span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">In a graph, “visit a node” means simply to “mark the node as visited.”"</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">Where a graph traversal starts = "a graph tra- versal begins at any vertex—called the <b>origin vertex</b>—and visits only the vertices that it can reach. Only when a graph is connected can such a traversal visit all the vertices."</span></span></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.12 Breadth First Traversal AKA. Shallow  Traversal</b></div>
<div><b><br/></b></div>
<div>Algorithm</div>
<div><br/></div>
<div>// Uses two queues, one for the traversalOrder, and one for a temporary vertexQueue.</div>
<div>// Each visit of a node enqueues a node in the traversalOrder queue.</div>
<div>// Each time we finish a visit of all a node’s neighbors we dequeue the vertexQueue and repeat recursively until the queue is empty.</div>
<div> </div>
<div>Visit Origin</div>
<div>Visit all neighbors of Origin.</div>
<div>Repeat recursively</div>
<div><br/></div>
<div>"A breadth-first traversal visits a vertex and then each of the vertex’s neighbors before advanc- ing. The order in which these neighbors are visited is not specified and can depend on the graph’s implementation."</div>
<div><br/></div>
<div>// This algorithm uses a queue because you need a way to know which node’s neighbors you haven’t visited yet. By enqueueing as you visit you know what node to backtrack to continue the breadth first search.</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/3C674EA3-E3D1-42A9-AF28-E9DBCD0F08A3.png" height="686" width="1138"/></div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><br/></div>
<div><b>-Section 28.13 Depth First Traversal AKA. Deep Traversal</b></div>
<div><b><br/></b></div>
<div>// Stacks an recursion are intimately related.</div>
<div><br/></div>
<div>Algorithm</div>
<div><br/></div>
<div>// Uses a queue for the traversalOrder and a vertexStack to do the traversal.</div>
<div> </div>
<div>Visit origin</div>
<div>push origin</div>
<div>while stack not empty</div>
<div>     topVertex=peek</div>
<div>     if topVertex has unvisited neighbor</div>
<div>          visit neighbor</div>
<div>          push neighbor</div>
<div>     else</div>
<div>          pop</div>
<div><br/></div>
<div>"A depth-first traversal visits a vertex, then a neighbor of the vertex, a neighbor of the neigh- bor, and so on, advancing as far as possible from the original vertex. It then backs up by one vertex and considers another neighbor. The order in which these neighbors are visited is not specified and can depend on the graph’s implementation."</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/AD6437EC-90F0-4614-84EC-47208F0043B6.png" height="883" width="1119"/></div>
<div><br/></div>
<div>TODO!!!: Self test questions on traversal order.</div>
<div><br/></div>
<div>
<hr/></div>
<div><br/></div>
<div><b>-Section 28.14 Topological Order AKA. Course Pre-requisites Order </b></div>
<div><br/></div>
<div><br/></div>
<div>"In a topological order of the vertices in a directed graph without cycles, vertex a pre- cedes vertex b whenever a directed edge exists from a to b."</div>
<div><br/></div>
<div><br/></div>
<div>"A topological order is not possible for a graph that has a cycle."</div>
<div><br/></div>
<div>"This circular logic is caused by the cycle and creates an impossible situation."</div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><br/></div>
<div><b>-Section 28.15 More on Topological Order AKA. Course Pre-requisites Order </b></div>
<div><br/></div>
<div>"We can begin a topological sort by locating a vertex that has no successor, that is, no adjacent vertex. Finding this vertex is possible because the ￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼</div>
<div>graph has no cycles. We mark the vertex as visited and push it onto a stack. We continue by finding another vertex u that is unvisited and whose neighbors, if any, are visited. We mark u as visited and push it onto the stack. We proceed in this way until we have visited all the vertices. At that time, the stack contains the vertices in topological order, beginning at the top of the stack."</div>
<div><br/></div>
<div>Use a stack , starting with the node that has no outgoing edges (node has no successor, more than one such node can exist), push that node, then work you way backward by finding the next node that is unvisited itself but whose neighbors are already visited. </div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div>Paths</div>
<div>
<hr/></div>
<div><b>-Section 28.16 Finding A Path</b></div>
<div><br/></div>
<div>Note the distinction between the following tasks:</div>
<div>1. Find a path, any path between a and b.</div>
<div>2. Find the shortest path.</div>
<div><br/></div>
<div>For #1, finding any path between a and b. We can use a depth first traversal.</div>
<div><br/></div>
<div>Start the traversal at vertex a (so it is the origin), and as you traverse you check each time whether you have reached vertex b, and if so stop there.</div>
<div>Recall that we use a stack+queue to do a depth first traversal. "resulting stack contains the path”. "Other- wise, we continue the traversal until either we are successful or the traversal ends."</div>
<div><br/></div>
<div>//TODO: Implement this..</div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.17 The shortest path in an unweighted graph.</b></div>
<div><br/></div>
<div>In an unweighted graph the shortest is defined by the number of edges along the path, AKA the length of the path.</div>
<div><br/></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/53FB276F-971B-4F0F-9422-B059AD8699F5.png" height="932" width="1623"/></div>
<div><br/></div>
<ul>
<li>Figure 28-17
<ul>
<li>The front of the queue becomes the front of the breath first traversal. =frontVertex.</li>
<li>visit all neighbors of frontVertex.</li>
<li>Each time we visit a vertex
<ul>
<li>set cost to vertex=cost to frontvertex+cost to this vertex.</li>
<li>set predecessor</li>
<li>enqueue in vertex queue. Notice that the queue is filled only with vertices that are marked as visited.</li>
</ul>
</li>
<li>Repeat until vertex queue is empty or next neighbor = end vertex.</li>
</ul>
</li>
<li>How do we know this algorithms gives the shortest path?
<ul>
<li>in an unweighted graph each edge has an equal cost. Since we are doing a breath first traversal, when we reach endVertex for the first time we know that any subsequent vertices will lead to paths that have either have the same or greater path lengths.</li>
<li>Think of the traversal as a traversal of a tree in level order where the root of the tree is the origin vertex. A level order traversal of a tree  is like a breadth first traversal of a graph.</li>
</ul>
</li>
<li>The get shortest path algo. is almost identical to the get breadth first traversal algo. minus storing of the predecessor and cost and stopping the iteration when end vertex is reached.</li>
</ul>
<div>
<hr/></div>
<div><b>-Section 28.18 Developing the algorithm - shortest path in an unweighted graph</b></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"In an unweighted graph, the shortest path between two given vertices ... has the fewest edges. The algorithm to find this path is based on a <b>breadth</b>- first traversal. If several paths have the same shortest length, <b>the algorithm will find only one of them</b></span><span style="font-size: 10.000000pt; font-family: 'Giovanni'; font-weight: 700">."</span></div>
<div><span style="font-size: 10pt;"><span style="font-family: Giovanni;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: Giovanni;">"To find the shortest path, we enhance the breadth-first traversal as follows. When we visit a vertex v and mark it as visited, we note the vertex p that we just left to reach v. That is, p precedes v in the graph. We also note the length of the path that the traversal followed to reach v. This length is 1 more than the length of the path to vertex p. We place both the length of the path to v and a refer- ence to p into vertex v. At the end of the traversal, we will use this data in the vertices to construct the shortest path."</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: Giovanni;"><br/></span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: Giovanni;">"by examining the destination vertex—H—we find that the length of the shortest path from A to H is 2."</span></span></div>
<div><span style="font-size: 10pt;"><span style="font-family: Giovanni;"><br/></span></span></div>
<div><img src="Chapter%2028%3A%20Graphs.html.resources/BDDE6350-3FC1-41C2-BED1-03233D427DF8.png" height="458" width="1066"/></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.19 The algorithm</b></div>
<div><br/></div>
<div><span style="font-size: 10pt;"><span style="font-family: TimesNewRoman;">int Algorithm getShortestPath(in originVertex, in endVertex, out pathstack)</span></span></div>
<div>
<hr/></div>
<div><b>-Section 28.20 Tracing the algorithm</b></div>
<div><br/></div>
<div><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">"The algorithm continues in this manner and eventually encounters the destination vertex,</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Italic'">H</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">. After</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Italic'">H</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">is updated, the outer loop ends. We then construct the path by working back from</span> <span style="font-size: 10.000000pt; font-family: 'TimesNewRoman,Italic'">H [using a stack]</span><span style="font-size: 10.000000pt; font-family: 'TimesNewRoman'">, as we did earlier in Segment 28.18."</span></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.21 The Shortest Path in a Weighted Graph</b></div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.22 Developing the algorithm - shortest path in a weighted graph</b></div>
<div><b><br/></b></div>
<div><br/></div>
<div><b><br/></b></div>
<div>
<hr/></div>
<div><b>-Section 28.23 Tracing the algorithm - shortest path in a weighted graph</b></div>
<div><b><br/></b></div>
<div>Very similar to a unweighted graph shortest path algorithm but we use a priority queue where priority is based on the summed path weight. Instead of visiting neighbors right away and then enqueueing them, we don’t visit them and immidiately enqueue all neighbors. Once that is done we dequeue , and since this is a priority queue that node will be the one with the lowest weight. "Note that several entries in the priority queue might contain the same vertex but different costs."</div>
<div><br/></div>
<div><br/></div>
<div>
<hr/></div>
<div><b>-Section 28.24 The algorithm - shortest path in a weighted graph</b></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div>"This algorithm is based on Dijkstra’s algorithm, which finds the shortest paths from an origin to<b> all </b>other vertices."</div>
<div><br/></div>
<div>
<hr/></div>
<div><b>Java Interfaces for the ADT Graph</b></div>
<div>
<hr/></div>
<div><b>-Section 28.25-&gt;28 </b></div>
<div><br/></div>
<div>"The ADT graph is a bit different from other ADTs in that, once you create it, you do not add, remove, or retrieve components. Instead, you use a graph to answer questions based on the relationships among its vertices."</div>
</body></html>